barplot(t)
barplot.default(t)
barplot(t)
n <- floor(rnorm(10000, 500, 100))
t <- table(n)
barplot(t)
n <- c(rnorm(10000, 500, 100)
axis(side = 1, at = axis_bounds, pos = 0)
axis_bounds <- seq(sd_axis_bounds * population_sd + population_mean, sd_axis_bounds * population_sd + population_mean, by = population_sd)
# Men's heights are normally distributed with a population mean of 69.0 inches
# and a population standard deviation of 2.8 inches
population_mean <- 69
population_sd <- 2.8
sd_to_fill <- 1
lower_bound <- population_mean - population_sd * sd_to_fill
upper_bound <- population_mean + population_sd * sd_to_fill
# Generates equally spaced values within 4 standard deviations of the mean
# This is used to connect the points on the curve so the more points the better
x <- seq(-4, 4, length = 1000) * population_sd + population_mean
# Returns the height of the probably distribution at each of those points
y <- dnorm(x, population_mean, population_sd)
# Generate the plot, where:
# - type: the type of plot to be drawn where "n" means do not plot the points
# - xlab: the title of the x axis
# - ylab: the title of the y axis
# - main: the overall title for the plot
# - axes: when false it suppresses the axis automatically generated by the high level plotting function so that we can create custom axis
plot(x, y, type="n", xlab = "Height (inches)", ylab = "", main = "Distribution of Men's Heights", axes = FALSE)
# Connect all of the points with each other to form the bell curve
lines(x, y)
# Returns a vector of boolean values representing whether the x value is between the two bounds then
# filters the values so that only the ones within the bounds are returned
bounds_filter <- x >= lower_bound & x <= upper_bound
x_within_bounds <- x[bounds_filter]
y_within_bounds <- y[bounds_filter]
# We want the filled in area to extend all the way down to the y axis which is why these two lines are necessary
# It makes the first point in the polygon (lower_bound, 0) and the last point (upper_bound, 0)
x_polygon <- c(lower_bound, x_within_bounds, upper_bound)
y_polygon <- c(0, y_within_bounds, 0)
polygon(x_polygon, y_polygon, col = "red")
# Now determine the probability that someone falls between the two bounds so we can display it above the curve
# Remember that pnorm returns the probability that a normally distributed random number will be less than the given number
probability_within_bounds <- pnorm(upper_bound, population_mean, sd) - pnorm(lower_bound, population_mean, population_sd)
# Concatenate the various values so we can display it on the curve
text <- paste("p(", lower_bound, "< height <", upper_bound, ") =", signif(probability_within_bounds, digits = 3))
# Display the text on the plot. The default "side" parameter is 3, representing the top of the plot.
mtext(text)
# Add an axis to the current plot, where:
# - side: which side of the plot the axis should be drawn on where 1 represents the bottom
# - at: the points at which the tick-marks are to be drawn
# - pos: the coordinate at which the axis line is to be drawn
sd_axis_bounds = 5
axis_bounds <- seq(-sd_axis_bounds * population_sd + population_mean, sd_axis_bounds * population_sd + population_mean, by = population_sd)
axis(side = 1, at = axis_bounds, pos = 0)
install.packages("tidyverse")
library('tidyverse')
library(tidyverse)
ggplot(data = mpg) +
geom_point(mapping = aes(x = displ, y = hwy))
ggplot(data = mpg)
#Set the working directory to where Titanic Files are located
setwd("C:/Users/nicho/OneDrive/Desktop/2019-2020/Data Science/Kaggle Titanic/Titanic Competition")
#Have RStudio read the csv files
ship.train <- read.csv(file = "train.csv", stringsAsFactors = FALSE, header = TRUE)
ship.test <- read.csv(file = "test.csv", stringsAsFactors = FALSE, header = TRUE)
#Combine them
ship.train$IsTrainSet <- TRUE
ship.test$IsTrainSet <- FALSE
ship.test$Survived <- NA
ship.full <- rbind(ship.train, ship.test)
#Clean data in ship.full for Embarked
ship.full[ship.full$Embarked == '', "Embarked"] <- 'S'
#Clean data in ship.full for Age
age.median <- median(ship.full$Age, na.rm = TRUE)
ship.full[is.na(ship.full$Age), "Age"] <- age.median
#Clean data in ship.full for Fare using Predictve Model
upper.boundary <- boxplot.stats(ship.full$Fare)$stats[5]
outlier.filter <- ship.full$Fare < upper.boundary
ship.full[outlier.filter,]
fare.equation = "Fare ~ Pclass + Sex + Age + SibSp + Parch + Embarked"
fare.model <- lm(
formula = fare.equation,
data = ship.full[outlier.filter,]
)
fare.row <- ship.full[
is.na(ship.full$Fare),
c("Pclass", "Sex", "Age", "SibSp", "Parch", "Embarked")
]
fare.predictions <- predict(fare.model, newdata = fare.row)
ship.full[is.na(ship.full$Fare), "Fare"] <- fare.predictions
#Categorial casting
ship.full$Pclass <- as.factor(ship.full$Pclass)
ship.full$Sex <- as.factor(ship.full$Sex)
ship.full$Embarked <- as.factor(ship.full$Embarked)
#Throw this back into the .csv files
ship.train<- ship.full[ship.full$IsTrainSet == TRUE,]
ship.test <- ship.full[ship.full$IsTrainSet == FALSE,]
#Handle Survived Case
ship.train$Survived <- as.factor(ship.train$Survived)
#Build Predictive Model Using Formulas and Random Forests
survived.equation <- "Survived ~ Pclass + Sex + Age + SibSp + Parch + Fare + Embarked"
survived.formula <- as.formula(survived.equation)
install.packages("randomForest")
library(randomForest)
ship.model <- randomForest(formula = survived.formula, data = ship.train, ntree = 500, mtry = 3, nodesize = 0.01 * nrow(ship.test))
#Features
features.equation <- "Pclass + Sex + Age + SibSp + Fare + Embarked"
Survived <- predict(ship.model, newdata = ship.test)
#Turning results back out into a .csv file
PassengerId <- ship.test$PassengerId
output.df <- as.data.frame(PassengerId)
output.df$Survived <- Survived
write.csv(output.df, file="kaggle_submission.csv", row.names = FALSE)
boxplot(ship.full$Fare)
boxplot(ship.train$Fare)
setwd("C:/Users/nicho/OneDrive/Desktop/2019-2020/Data Science/Kaggle Titanic/Titanic Competition")
setwd("~/")
setwd("C:/Users/nicho/OneDrive/Desktop/2019-2020/Data Science/Kaggle Titanic/Titanic Competition")
